## Screen Recording

[Here](https://youtu.be/gCp2fsrctUE) is a screen recording of the process described below.

## Local Tests Using Github Bot Scripts
This document provides info on how to run some dev related scripts. These exact scripts are run as part of the GitHub workflow during homework submission. There are other scripts not listed here but those are for submission check itself.

### Setup Dev Machine
- OS: ubuntu-18.04
- Clone the repo
```bash
git clone https://github.com/a-teaching-goose/2022-342-sprint-1 #example here, put the repo you are working on
```
- Install required dependencies
```bash
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1$ pwd
/home/ubuntu/2022-342-sprint-1
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1$ ./.github/workflows/install_dependencies.sh
```

**Note: Pay attention to which folder each command below is run**

### Create Makefiles
CMake creates lots of temp files so it's a good idea to use a build folder. All build is done in the build folder.
```bash
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1$ mkdir build
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1$ cd build
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1/build$ cmake -DCMAKE_BUILD_TYPE=Debug -DRUN_COV=true ..
```
The "-DCMAKE_BUILD_TYPE=Debug" flag is for coverage test and can be ommited for other build targets.

### Build

Before running any cmake targets, build all the source code (your code, dependencies, etc.)

```bash
ubuntu@ip-172-31-19-254:~/2022-342-sprint-1/build$ make -j4
```

The optional flag "-j4" is to ask Make to build with 4 threads [in parallel](https://www.gnu.org/software/make/manual/html_node/Parallel.html). 

Pretty cool eh?

There are a few build targets in this project:

#### Unit Test 
The unit test build target is [here](https://github.com/a-teaching-goose/2022-342-sprint-1/blob/03b55613693da0cee99191c10069dcc9faecef59/test/CMakeLists.txt#L1)

This is defined as a custom target [here](https://github.com/a-teaching-goose/2022-342-sprint-1/blob/fd3a94334df27a9e93c5c78f1340222312f87ffb/CMakeLists.txt#L47)

To run:

```bash
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1/build$ make function_tests
```

This runs targets that end in '_test'.

#### Playground

This is where you can play with things around. 

The playground build target in [here](https://github.com/a-teaching-goose/2022-342-sprint-1/blob/fd3a94334df27a9e93c5c78f1340222312f87ffb/src/CMakeLists.txt#L3)

This can be run by
```bash
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1/build$ ../bin/css342_homework
```

#### Memory Check

The memory check build target is [here](https://github.com/a-teaching-goose/2022-342-sprint-1/blob/fd3a94334df27a9e93c5c78f1340222312f87ffb/CMakeLists.txt#L48)

To run the target:
```bash
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1/build$ make mem_tests
```

A script is provided to run the target and perform checks:
```bash
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1/build$ ../.github/workflows/memcheck.sh
```

Note: memcheck.sh contains "make mem_tests" already so only this script is needed to check for memory issue (e.g. leaks).

#### Code Coverage

The code coverage target is defined [here](https://github.com/a-teaching-goose/2022-342-sprint-1/blob/fd3a94334df27a9e93c5c78f1340222312f87ffb/CMakeLists.txt#L58)

Note: this is only for Linux environment.

To run the target:
```bash
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1/build$ make coverage_check -j4 |tee /tmp/342_coverage_check.out
```

Here "tee" is used to log the output of make to */tmp/342_coverage_check.out*.

There are plenty of output so a script is provided to verifies coverage against pre-defined coverage bars:

``` bash
ubuntu@ip-172-31-46-44:~/2022-342-sprint-1/build$ ../.github/workflows/coverage_check.sh
```

Note: coverage_check.sh **ONLY** validates the coverage result against required bars. The actually coverage numbers are generated by "make coverage_check". This is a different situation from mem check.

*... Wait, it gets better ...*

Once coverage target is run, you can start a webserver to see the actual coverage in code

```
ubuntu@ip-172-31-19-254:~/2022-342-sprint-1/build$ ../.github/workflows/host_coverage_server.sh
```

This opens up a tiny webserver for the coverage result. For this to work, you might need to add "allow HTTP" in the security group of the VM. [Here is how to do it for AWS](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html) 

Go to your local browser and open the public ip of the linux instance, and the report would come up:

![image](https://user-images.githubusercontent.com/252020/148663293-86ad9736-e14c-464f-95e3-0f54851cbad4.png)

Click into each folder and you'll see line coverage like this

<img src="https://user-images.githubusercontent.com/252020/148663361-49aa92ea-f9f3-418f-84c7-05ec7a7bd5ed.png" width="700">


Pretty fancy, eh ;)

